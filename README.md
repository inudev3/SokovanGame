##1단계
문자열을 줄바꿈을 기준으로 나누어 2차원 배열로 만들고, 스테이지 구분선을 기준으로
스테이지를 나누어 배열에 저장하였습니다.
그 후, 문제에 주어진 조건에 따라 각 문자열을 파싱하는 parser함수와,
파싱된 숫자 정보를 읽어 props객체를 생성하는 props함수를 만들어
스테이지 정보 뒤에 붙여넣고 스테이지 구분선을 제외한 나머지가 출력되게 하였습니다.


##2단계
  콘솔 입력을 위해 readline을 사용하여 프롬프트를 띄운 후 사용자 입력을 받아 지정된 방향키에 따라
플레이어 위치 마커가 이동하도록 했습니다. 이동할 시에는 1단계의 숫자정보로 파싱된 상태에서 맵에 장애물이
입력한 숫자만큼 이동했을 경우 장애물이 있는지 여부를 확인하여 있을 대는 경고를 출력하고, 없을 때는 다시 문자열로 파싱한 결과를 출력하도록 했습니다. 

#3단계
  콘솔 입력을 위해 readline을 사용하였으나 주어진 조건에 따라 메 라인 입력이 끝날 때마다 스테이지 클리어를 위한 조건을 충족하였는지를
검사해야하는 로직이 필요했다. 검사 로직은 따로 분리하고, readline을 써본 적이 없어 on('line')이라는 이벤트리스너를 통해
클리어 조건을 구현하려고 하였으나, 클리어 조건을 충족하지 않음에도 불구하고 다음 단계로 넘어가는 문제가 발생했다.
다음 단계로 넘어 가는 것은, 스테이지를 제네레이터 함수를 통해 이터러블로 만들고 클리어 조건이 충족될 때 재귀적으로 next를 호출하는 것으로 해결하려 하였다.
검색해보니 readline이 비동기적으로 작동한다고 되어있어, 재귀/제네레이터와 함께 정상적으로 동작하지 않는 것처럼 보인다.
모든 단계에서 로직은 최대한 분리하려 하였으나, readline의 기능을 잘 이해하지 못해 분리하지 못하였고, 각 단계에서 
오브젝트 정보와 숫자 정보를 파싱해야하는 경우에 switch문을 사용하여 길이가 길어지는 것을 감수해야 했다.
readline의 클리어 조건과 재귀함수가 정상적으로만 동작한다면 다른 에러는 없는 것처럼 보이나, 현재는 명시한 클리어 조건에 도달하지
인 현재 '0'의 개수와 구멍의 개수가 정상적으로 출력됨에도 불구하고 검사로직이 작동하지 않는 상태이다(그 전에 스테이지 단계가 이동해버린다.)
```
Sokovan(parsed, line, turnCount, holes);
      const curr = currCount(parsed);
      console.log(curr,goals) //정상적으로 출력된다.
        if(curr===goals){ //목표개수에 도달하면 작동해야하는데, 이상하게
            console.log("Cleared!");
            console.log("축하합니다!\n 턴수:", turnCount);
            ReadLine(gen);
        }
        else{
            rl.prompt();
        }
```
